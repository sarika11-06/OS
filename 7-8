#SDPTA
import numpy as np
# Initialize weight matrix
w = np.array([[1, 1, 0, 0.5]]).T # Column vector for weights
# Input data
xi = np.array([[1, -2, 0, 1], [0, 1.5, 0.5, -1], [-1, 1, 0.5, -1]]).T
# Each column is a feature vector
# Desired output
d = np.array([-1, 1, 1])
# Learning rate
c = 0.1
# Training Loop
error = -1
iteration = 0
print("Initial Weight Matrix:\n", w)
while error != 0:
  error = 0
  for i in range(len(xi.T)):
    net = np.sum(w.T @ xi[:, i])
    print(f"Iteration {iteration + 1}, Sample {i + 1} : Net Input: {net:.4f}")
    o = 1 if net >= 0 else -1
    e = d[i] - o
    error += 0.5 * e**2
    dw = c * e * xi[:, i].reshape(-1, 1)
    w += dw
    print(f"Error: {e:.4f}")
    print(f"Updated Weight Matrix:\n{w.T}\n")
    iteration += 1

  if error == 0:
    break
print("\nFinal Weight Matrix: \n", w)



#SCPTA
import numpy as np
# Initialize weight matrix
w = np.array([[1, -1, 0, 0.5]]).T
# Input data
xi = np.array([[1, -2, 0, -1], [0, 1.5, 0.5, -1], [-1, 1, 0.5, -1]]).T
# Desired output
d = np.array([-1, 1, 1])
# Learning rate
c = 0.1
# Initialize error and iteration counter
Error = -1
error = 1
iteration = 0
print("Training Process Begins...\n")
while Error != 0.0:
  iteration += 1
  for i in range(len(xi.T)):
    net = sum(w.T @ xi[:, i])
    print(f"Iteration {iteration}, Sample {i+1}:")
    print(f"Net: {net:.4f}")
    # Activation function
    o = (2 / (1 + np.exp(-1 * net))) - 1
    o = 0.5 * (1 + o * 2)
    # Compute error
    error += 0.5 * ((d[i] - o) ** 2)
    print(f"Error: {error:.4f}")
    # Round error and update weights
    Error = round(error, 1)
    dw= c * (d[i] - o) * xi[:, i].reshape(-1, 1)
    w += dw
  print("Updated Weight Matrix:\n", w, "\n")
    # Stop when error reaches zero
  if Error == 0.0:
    break
    # Stop condition to prevent infinite loop
  if iteration >= 8:
    print("\nProcess keeps going... Stopping after 8 iterations!\n")
    break

from collections import defaultdict

def get_prob_matrix(rows, cols, name):
    # Prompt the user and read a rows x cols probability matrix (row-wise)
    print(f"\nEnter {name} probabilities (row-wise, space-separated):")
    matrix = []
    for i in range(rows):
        row_in = input(f"Row {i+1}: ")
        row = list(map(float, row_in.split()))
        if len(row) != cols:
            raise ValueError(f"Each row must have {cols} values")

        s = sum(row)
        if abs(s - 1.0) > 1e-8:
            print(f"Warning: row {i+1} of {name} sums to {s:.6f}; normalizing it.")
            row = [x / s for x in row]

        matrix.append(row)
    return matrix


def forward_algorithm(obs_seq, states, start_prob, trans_prob, emis_prob, obs_dict):
    n_states = len(states)
    T = len(obs_seq)

    # forward probability table
    fwd = [[0.0] * n_states for _ in range(T)]

    # --- Initialization ---
    for s in range(n_states):
        obs_idx = obs_dict[obs_seq[0]]
        fwd[0][s] = start_prob[s] * emis_prob[s][obs_idx]

    # --- Recursion ---
    for t in range(1, T):
        obs_idx = obs_dict[obs_seq[t]]
        for j in range(n_states):
            total = 0.0
            for i in range(n_states):
                total += fwd[t - 1][i] * trans_prob[i][j]
            fwd[t][j] = total * emis_prob[j][obs_idx]

    # --- Termination ---
    prob = sum(fwd[T - 1][s] for s in range(n_states))
    return prob


def predict_tomorrow(today_state, states, trans_prob):
    """Predict tomorrow's weather given today's weather."""
    idx = states.index(today_state)
    tomorrow_probs = trans_prob[idx]
    return {states[i]: tomorrow_probs[i] for i in range(len(states))}


states = ["Sunny", "Cloudy", "Rainy"]
observations = ["Normal", "Umbrella", "Raincoat"]

print("Hidden Markov Model for Weather Prediction\n")

print("Enter initial state probabilities (Sunny Cloudy Rainy):")  
# 0.3 0.5 0.2
start_prob = list(map(float, input().split()))

if len(start_prob) != len(states):
    raise ValueError("Invalid number of initial probabilities")

s = sum(start_prob)
if abs(s - 1.0) > 1e-8:
    print(f"Warning: initial probs sum to {s:.6f}; normalizing.")
    start_prob = [x / s for x in start_prob]   # FIXED variable name


# Transition and emission probabilities
trans_prob = get_prob_matrix(len(states), len(states), "transition (state-to-state)")

# Row 1: 0.6 0.3 0.1
# Row 2: 0.2 0.5 0.3
# Row 3: 0.1 0.4 0.5

emis_prob = get_prob_matrix(len(states), len(observations), "emission (state-to-observation)")

# Row 1: 0.5 0.3 0.2
# Row 2: 0.4 0.3 0.3
# Row 3: 0.1 0.4 0.5

# Observation sequence
obs_seq = input("\nEnter observation sequence (e.g., Normal Umbrella Raincoat): ").split()
# Raincoat Normal Umbrella Raincoat
obs_set = set(observations)

for o in obs_seq:
    if o not in obs_set:
        raise ValueError(f"Unknown observation '{o}'. Allowed: {observations}")

obs_dict = {obs: i for i, obs in enumerate(observations)}

# Run forward algorithm
prob = forward_algorithm(obs_seq, states, start_prob, trans_prob, emis_prob, obs_dict)
print(f"\nProbability of the observation sequence {obs_seq} is: {prob:.6f}")

# Predict tomorrow
today_state = input("\nEnter today's weather (Sunny/Cloudy/Rainy) to predict tomorrow: ")
if today_state not in states:
    print("Invalid state. Allowed states:", states)
else:
    tomorrow = predict_tomorrow(today_state, states, trans_prob)
    print("Predicted probabilities for tomorrow's weather:", tomorrow) 
    # Sunny
